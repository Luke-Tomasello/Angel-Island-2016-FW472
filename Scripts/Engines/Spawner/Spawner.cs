/***************************************************************************
 *
 *   RunUO                   : May 1, 2002
 *   portions copyright      : (C) The RunUO Software Team
 *   email                   : info@runuo.com
 *   
 *   Angel Island UO Shard   : March 25, 2004
 *   portions copyright      : (C) 2004-2024 Tomasello Software LLC.
 *   email                   : luke@tomasello.com
 *
 ***************************************************************************/

/***************************************************************************
 *
 *   This program is free software; you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation; either version 2 of the License, or
 *   (at your option) any later version.
 *
 ***************************************************************************/

/* Scripts/Engines/Spawner/Spawner.cs
 * Changelog:
 *	3/6/16, Adam
 *		1. Comment out the *display* of the OurWorldSize stuff... not sure why it's here and atleast makes the display ugly
 *		We will look into this later and try and track down the reasoning.
 *		2. Make our event spawners print more useful information, and allow them to take an expiration date.
 *	3/30/10. adam
 *		1. Add EventSpawner class
 *		2. Force a recalc of NextSpawn if Min or Max are changed
 *	2/23/10, Adam
 *		Limit paragons to players using dragons or daemons to farm
 *	5/12/09, Adam
 *		Check for value==null when setting the LootPack
 *	01/14/09, plasma
 *		Added OnAfterMobileSpawn( Mobile )
 *	10/28/08, plasma
 *		Virtualised Spawn()
 *	10/17/08, Adam
 *		In OnDelete make sure to delete all templates!
 *	10/16/08, Adam
 *		- Add a LootPack Item (or container item) that specifies special loot for creatures generated by this spawner. BaseCreature takes care of the actual interpretation of this value.
 *      - Make sure the current lootpack is deleted before a new one is assigned.
 *      - Make sure to remove the loot from the parent container.
 *	4/20/08, Adam
 *		Make GetSpawnPosition() a public function
 *	11/1/07, Adam
 *		When using target mode to setup a Template Item or Mobile, set/clear the SpawnerTempMob or SpawnerTempItem for the template
 *		We need to clear it for the old Template so that it will decay as per usual, and set it for the new one so that it does not 
 *		decay. 
 *		Caution: Don't use anything spawned by a spawner (still on the spawner list) as a template as the spawner will delete it
 *		during a defrag.
 *	8/28/07, Adam
 *		Add a 10% chance to ,ake the spawned creature a Paragon.
 *		The actual decision is in BaseCreature, the spawner only creates the chance.
 *  3/21/07, Adam (removed)
 *      Add DynamicLootTypes for dynamic loot specification.
 *  3/17/07, Adam
 *      Split spawn into a Create function and a Move to world portion.
 *      This is so we can have a public Factory method to create Template Mobiles and Items.
 *  2/26/07, Adam
 *      Make sure to call m_Timer.Flush() to remove any queued ticks.
 *      This is important when setting NextSpawn and there is already a queued tick.
 *  10/19/06, Kit
 *		Made template mobs spawner property be set to spawner they are on.
 *	10/18/06, Adam
 *		- Remove notion of 'Fixed' non-decaying objects
 *		- Refresh() items still on a spawner before decaying (called by ItemDecay in Heartbeat)
 *	9/15/06, Adam
 *		Add function to create a template object only if the Type of the existing template
 *			object has changed. The prevents complex templates from being lost when someone
 *			simply hits 'OK' on the Spawner gump
 *	9/3/06, Adam
 *		Add function to get the Creature List
 *  8/16/06, Kit
 *		Made static copy of mobs copy layers and propertys of those layers to new destination mob.
 *  7/02/06, Kit
 *		Added, property DynamicCopy, if enabled call InitOutfit/InitBody routines of mob.
 *		Added set NameHue to -1(use notority) for vendors spawned with invunerability turned off.
 *		Fixed bug with namehue being set on all spawners.
 *		Added call to InitOutfit() for normal template spawns to prevent cross dressing.
 *	6/30/06, Adam
 *		- remove evil code nulling templates on every spawn if Enable is not set
 *		- Have TemplateEnable invoke appropriate Template Creation / Destruction code
 *		- Propagate Lifespan for Mobiles and LastMove for items (manages decay/cleanup)
 *		- move template creation/management into Spawner class.
 *		- make sure template is only created on the first object specified.
 *		- make TemplateEnable readable by GMs, but writable by Seers
 *  06/27/06, Kit
 *		Added templated ability to spawners, full range of props setting for spawner entry.
 *		Set via TemplateMobile -> view props, or TemplateItem -> view props, packed out old data.
 *  06/27/06, Kit
 *		Added new property MobVendorInvunerable, for setting invunerability on vendors.
 *	6/6/06, Adam
 *		Rename Nav --> m_NavDest to follow normal member naming conventions.
 *	1/9/06, Adam
 *		Change FreezeDecay to AccessLevel.Administrator - used for daily rares
 *	12/20/05, Adam
 *		Add many more attributes for defining dynamic creatures.
 *	12/19/05, Adam
 *		Add logging to the Name and Hue attributes.
 *	12/18/05, Adam
 *		Add the attributes Name and Hue to be applied to the spawned Object.
 *		These are Seer access attributes.
 *	12/16/05, Adam
 *		Warn if we're spawning stuff in a house.
 *		This is a problem becuse the item will be orphaned by the spawer
 *		which can lead to excessive item generation.
 *  12/05/05, Kit
 *		Spawner now calls Think() for creature if creature has a navdestination set.
 *  12/01/05, Kit
 *		Added Serilization for NavDestination
 *  11/29/05 Kit
 *		Added NavDestination property for setting default NavPoint.
 *  11/22/05 TK
 *		Correction MobileDirection to be a separate value from spawner's Item.Direction
 *  11/21/05 Taran Kain
 *      Added MobileDirection property, just a redirect to Item.Direction
 *	3/9/05, Adam
 *		In Defrag() we now check to see if the spawned item is in a HouseRegion.
 *		items in a HouseRegion are assumed to be 'freed' from the spawner and may therefore
 *		be removed from the spawners list of managed items.
 *		We needed this new check because putting an item in your house leaves the parent null which prevents 
 *		the 'fixed' item from decaying and a new item from being spawned. (See previous change)
 *	02/28/05, Adam
 *		1. Add new FreezeDecay property to freeze the decay on spawned items.
 *		2. When someone picks something up, parent is set to non-null. When this happens
 *			We can clear the 'Fixed' flag (item.Fixed = false).
 *		Detailed explanation: 
 *			Items are removed from the spawners list of spawned items during the Defrag() run. 
 *			This Defrag() run is roughly the frequency of the spawner. In the case of daily rares, 
 *			this respawn rate can be days long.
 *			Because spawned rares must necessarily sit on the ground for days and not decay, 
 *			they have a special 'fixed' attribute that prevents them from decaying.
 *			When a player gets a rare home, it will still be fixed until the spawner next runs and 
 *			defrags. When this happens, the 'fixed' attribute will be cleared, and the item will 
 *			decay as usual.
 *	02/28/05, erlein
 *		Now also logs addition and deletion of spawners.
 *	02/27/05, erlein
 *		Added logging of HomeRange and Count property changes.
 *		Now logs all changes to these in /logs/spawnerchange.log
 *	12/29/04, Pix
 *		Now spawned creatures contain the location of the spawner.
 *  6/5/04, Pix
 *		Merged in 1.0RC0 code.
 */

using Server.Commands;
using Server.Engines;
using Server.Items;
using Server.Regions;
using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Reflection;

namespace Server.Mobiles
{
    public class Spawner : Item
    {
        public enum BOOL
        {
            bDefault = -1,
            bTrue = 1,
            bFalse = 0
        };

        private int m_Team;
        private int m_HomeRange;
        private int m_Count;
        private TimeSpan m_MinDelay;
        private TimeSpan m_MaxDelay;
        private ArrayList m_ObjectNames;
        private ArrayList m_Objects;
        private DateTime m_End;
        private InternalTimer m_Timer;
        private bool m_Running;
        private bool m_Group;
        private bool m_TemplateEnabled;
        private bool m_DynamicCopy;
        private WayPoint m_WayPoint;
        private Direction m_MobDirection;
        private NavDestinations m_NavDest;
        private BOOL m_MobVendorInvul = BOOL.bDefault;
        private Mobile m_TemplateMobile;
        private Item m_TemplateItem;
        private Item m_LootPack;
        private CoreAI.WorldSize m_OurWorldSize = CoreAI.WorldSize.Small | CoreAI.WorldSize.Medium | CoreAI.WorldSize.Large | CoreAI.WorldSize.Full;


        #region Publish 4 Siege (!Core.RuleSets.AngelIslandRules() && !Core.UOAR && !Core.RuleSets.MortalisRules() && PublishInfo.Publish >= 4)
        /*
		 * Publish 4
		 * Shopkeeper Changes
		 * If a shopkeeper is killed, a new shopkeeper will appear as soon as another player (other than the one that killed it) approaches.
		 * http://www.uoguide.com/Publish_4
		 */
        private Memory m_badGuys = !Core.RuleSets.AngelIslandRules() && !Core.RuleSets.RenaissanceRules() && !Core.RuleSets.MortalisRules() && PublishInfo.Publish >= 4 ? new Memory() : null;
        public Memory BadGuys { get { return m_badGuys; } }
        public override bool HandlesOnMovement { get { return (!Core.RuleSets.AngelIslandRules() && !Core.RuleSets.RenaissanceRules() && !Core.RuleSets.MortalisRules() && PublishInfo.Publish >= 4) ? true : false; } }
        public override void OnMovement(Mobile m, Point3D oldLocation)
        {
            if (m != null && m.Player)
            {   // we only have a memory (count > 0) if the spawned NPC died
                if (m_badGuys.Count > 0 && m_badGuys.Recall(m) == false)
                {   // if I need to spawn something and I don't remember this guy (m), spawn it now
                    this.NextSpawn = TimeSpan.Zero;     // now
                    m_badGuys = new Memory();           // we will respawn, no need for this old stale memory
                    this.SendMessage("[Staff Message] Instant spawn override: BaseVendor.OnDeath");
                }
            }

            base.OnMovement(m, oldLocation);
        }
        #endregion

        #region Templates
        [CommandProperty(AccessLevel.GameMaster, AccessLevel.Seer)]
        public bool TemplateEnabled
        {
            get
            {
                return m_TemplateEnabled;
            }
            set
            {
                if (value)
                    InitTemplate();
                else
                    DestrtoyTemplate();

                InvalidateProperties();
            }
        }

        [CommandProperty(AccessLevel.GameMaster, AccessLevel.Seer)]
        public bool DynamicCopy
        {
            get
            {
                return m_DynamicCopy;
            }
            set
            {
                m_DynamicCopy = value;
                InvalidateProperties();
            }
        }

        private void InitTemplate()
        {
            if (m_TemplateEnabled == true)
                return;

            m_TemplateEnabled = true;

            if (m_ObjectNames.Count > 0)
            {
                Type type = SpawnerType.GetType((string)m_ObjectNames[0]);
                CreateTemplate(this, type);
            }
        }

        private void DestrtoyTemplate()
        {
            if (m_TemplateEnabled == false)
                return;

            m_TemplateEnabled = false;

            // cleanup old templates
            if (TemplateMobile != null)
                TemplateMobile.Delete();
            TemplateMobile = null;

            if (TemplateItem != null)
                TemplateItem.Delete();
            TemplateItem = null;

        }

        //hold object for templated spawner use.
        [CommandProperty(AccessLevel.Seer)]
        public Mobile TemplateMobile
        {
            get { return m_TemplateMobile; }
            // if you are using target mode, this will clear the 'Template' field on the old one and set it on the new
            set
            {   // don't use spawner mobiles as templates because the spawner will delete the template on defrag
                if (m_TemplateMobile != null && m_TemplateMobile.Deleted == false)
                    m_TemplateMobile.SpawnerTempMob = false;    // unset the old

                m_TemplateMobile = value;

                if (m_TemplateMobile != null && m_TemplateMobile.Deleted == false)
                    m_TemplateMobile.SpawnerTempMob = true;     // reset the new
            }
        }

        //hold object for templated spawner use.
        [CommandProperty(AccessLevel.Seer)]
        public Item TemplateItem
        {
            get { return m_TemplateItem; }
            // if you are using target mode, this will clear the 'Template' field on the old one and set it on the new
            set
            {
                // don't use spawner items as templates because the spawner will delete the template on defrag
                if (m_TemplateItem != null && m_TemplateItem.Deleted == false)
                    m_TemplateItem.SpawnerTempItem = false;     // unset the old

                m_TemplateItem = value;

                if (m_TemplateItem != null && m_TemplateItem.Deleted == false)
                    m_TemplateItem.SpawnerTempItem = true;      // reset the new
            }
        }
        #endregion

        #region LootPack
        //hold object for templated spawner use.
        [CommandProperty(AccessLevel.GameMaster)]
        public Item LootPack
        {
            get { return m_LootPack; }
            set
            {   // delete the old one
                if (m_LootPack != null && m_LootPack.Deleted == false && m_LootPack != value)
                    m_LootPack.Delete();

                // remove from current container
                if (value != null && value.Parent != null && value.Parent is Container)
                    (value.Parent as Container).RemoveItem(value);

                // assign
                m_LootPack = value;

                // move to int item storage
                if (m_LootPack != null && m_LootPack.Deleted == false)
                    m_LootPack.MoveItemToIntStorage();
            }
        }
        #endregion

        [CommandProperty(AccessLevel.Seer)]
        public CoreAI.WorldSize OurWorldSize
        {
            get { return m_OurWorldSize; }

            set
            {
                m_OurWorldSize = value;
            }
        }

        // Adam: can be used for rares manufacture - must be seer level minimum
        [CommandProperty(AccessLevel.Seer)]
        public BOOL MobVendorInvunerable
        {
            get { return m_MobVendorInvul; }

            set
            {
                m_MobVendorInvul = value;
            }
        }

        public bool IsFull { get { return (m_Objects != null && m_Objects.Count >= m_Count); } }

        private Mobile m_LastProps; // erl: added to hold who last opened props on it
        public Mobile LastProps
        {
            get
            {
                return m_LastProps;
            }
            set
            {
                if (value is PlayerMobile)
                    m_LastProps = value;
            }
        }

        public List<Type> ObjectTypes
        {
            get
            {
                List<Type> list = new List<Type>();
                if (m_ObjectNames != null && m_ObjectNames.Count > 0)
                {
                    foreach (string name in m_ObjectNames)
                    {
                        Type type = SpawnerType.GetType(name);
                        if (type != null && list.Contains(type) == false)
                            list.Add(type);
                    }
                }
                return list;
            }
        }

        public ArrayList ObjectNames
        {
            get { return m_ObjectNames; }
            set
            {
                m_ObjectNames = value;
                if (m_ObjectNames.Count < 1)
                    Stop();

                InvalidateProperties();
            }
        }

        public ArrayList Objects
        {
            get { return m_Objects; }
        }

        [CommandProperty(AccessLevel.GameMaster)]
        public int Count
        {
            get { return m_Count; }
            set
            {
                if (m_Count != value)
                {
                    // erl: Log the change to Count
                    LogChange("Count changed, " + m_Count + " to " + value);
                }
                m_Count = value;
                InvalidateProperties();
            }
        }

        [CommandProperty(AccessLevel.GameMaster)]
        public WayPoint WayPoint
        {
            get
            {
                return m_WayPoint;
            }
            set
            {
                m_WayPoint = value;
            }
        }

        [CommandProperty(AccessLevel.GameMaster)]
        public NavDestinations NavPoint
        {
            get
            {
                return m_NavDest;
            }
            set
            {
                m_NavDest = value;
            }
        }

        [CommandProperty(AccessLevel.GameMaster)]
        public Direction MobileDirection
        {
            get
            {
                return m_MobDirection;
            }
            set
            {
                m_MobDirection = value;
            }
        }

        [CommandProperty(AccessLevel.GameMaster)]
        public bool Running
        {
            get { return m_Running; }
            set
            {
                if (value && (this.OurWorldSize & CoreAI.CurrentWorldSize) == 0)
                {
                    this.SendMessage("Unable to start spawner, please check OurWorldSize");
                    throw new ApplicationException("Unable to start spawner, please check OurWorldSize");
                }

                if (value && (this.OurWorldSize & CoreAI.CurrentWorldSize) != 0)
                    Start();
                else
                    Stop();

                InvalidateProperties();
            }
        }

        [CommandProperty(AccessLevel.GameMaster)]
        public int HomeRange
        {
            get { return m_HomeRange; }
            set
            {
                if (m_HomeRange != value)
                {
                    // erl: Log the change to HomeRange
                    LogChange("HomeRange changed, " + m_HomeRange + " to " + value);
                }
                m_HomeRange = value;
                InvalidateProperties();
            }
        }

        [CommandProperty(AccessLevel.GameMaster)]
        public int Team
        {
            get { return m_Team; }
            set { m_Team = value; InvalidateProperties(); }
        }

        [CommandProperty(AccessLevel.GameMaster)]
        public TimeSpan MinDelay
        {
            get { return m_MinDelay; }
            set { m_MinDelay = value; DoTimer(); InvalidateProperties(); }
        }

        [CommandProperty(AccessLevel.GameMaster)]
        public TimeSpan MaxDelay
        {
            get { return m_MaxDelay; }
            set { m_MaxDelay = value; DoTimer(); InvalidateProperties(); }
        }

        [CommandProperty(AccessLevel.GameMaster)]
        public TimeSpan NextSpawn
        {
            get
            {
                if (m_Running)
                    return m_End - DateTime.UtcNow;
                else
                    return TimeSpan.FromSeconds(0);
            }
            set
            {
                Start();
                DoTimer(value);
            }
        }

        [CommandProperty(AccessLevel.GameMaster)]
        public bool Group
        {
            get { return m_Group; }
            set { m_Group = value; InvalidateProperties(); }
        }

        [Constructable]
        public Spawner(int amount, int minDelay, int maxDelay, int team, int homeRange, string objectName)
            : base(0x1f13)
        {
            ArrayList objectNames = new ArrayList();
            objectNames.Add(objectName.ToLower());
            InitSpawn(amount, TimeSpan.FromMinutes(minDelay), TimeSpan.FromMinutes(maxDelay), team, homeRange, objectNames);
        }

        [Constructable]
        public Spawner(string objectName)
            : base(0x1f13)
        {
            ArrayList objectNames = new ArrayList();
            objectNames.Add(objectName.ToLower());
            InitSpawn(1, TimeSpan.FromMinutes(5), TimeSpan.FromMinutes(10), 0, 4, objectNames);
        }

        [Constructable]
        public Spawner()
            : base(0x1f13)
        {
            ArrayList objectNames = new ArrayList();
            InitSpawn(1, TimeSpan.FromMinutes(5), TimeSpan.FromMinutes(10), 0, 4, objectNames);

        }

        public Spawner(int amount, TimeSpan minDelay, TimeSpan maxDelay, int team, int homeRange, ArrayList objectNames)
            : base(0x1f13)
        {
            InitSpawn(amount, minDelay, maxDelay, team, homeRange, objectNames);
        }

        public void InitSpawn(int amount, TimeSpan minDelay, TimeSpan maxDelay, int team, int homeRange, ArrayList objectNames)
        {

            Visible = false;
            Movable = false;
            m_Running = true;
            m_Group = false;
            m_MobDirection = Direction.North;
            Name = "Spawner";
            m_MinDelay = minDelay;
            m_MaxDelay = maxDelay;
            m_Count = amount;
            m_Team = team;
            m_HomeRange = homeRange;
            m_ObjectNames = objectNames;
            m_Objects = new ArrayList();
            DoTimer(TimeSpan.FromSeconds(1));
        }

        public Spawner(Serial serial)
            : base(serial)
        {
        }

        public override void OnDoubleClick(Mobile from)
        {
            if (from.AccessLevel < AccessLevel.GameMaster)
                return;

            SpawnerGump g = new SpawnerGump(this);
            from.SendGump(g);
        }

        public override void GetProperties(ObjectPropertyList list)
        {
            base.GetProperties(list);

            if (m_Running)
            {
                list.Add(1060742); // active

                list.Add(1060656, m_Count.ToString()); // amount to make: ~1_val~
                list.Add(1061169, m_HomeRange.ToString()); // range ~1_val~

                list.Add(1060658, "group\t{0}", m_Group); // ~1_val~: ~2_val~
                list.Add(1060659, "team\t{0}", m_Team); // ~1_val~: ~2_val~
                list.Add(1060660, "speed\t{0} to {1}", m_MinDelay, m_MaxDelay); // ~1_val~: ~2_val~

                for (int i = 0; i < 3 && i < m_ObjectNames.Count; ++i)
                    list.Add(1060661 + i, "{0}\t{1}", m_ObjectNames[i], CountObjects((string)m_ObjectNames[i]));
            }
            else
            {
                list.Add(1060743); // inactive
            }
        }

        public override void OnSingleClick(Mobile from)
        {
            base.OnSingleClick(from);

            /*if (OurWorldSize.ToString().Contains(","))
				LabelTo(from, String.Format("for {0} worlds", OurWorldSize.ToString()));
			else
				LabelTo(from, String.Format("for a {0} world", OurWorldSize.ToString()));*/

            if (m_Running)
                LabelTo(from, "[Running]");
            else
                LabelTo(from, "[Off]");
        }

        public void Start()
        {
            if (!m_Running)
            {
                if (m_ObjectNames.Count > 0)
                {
                    m_Running = true;
                    DoTimer();
                }
            }
        }

        public void Stop()
        {
            if (m_Running)
            {
                m_Timer.Stop();
                m_Running = false;
            }
        }

        private bool InHouse(object o)
        {
            if (o != null)
            {
                IPoint3D ip = o as IPoint3D;
                Item item = o as Item;
                if (ip != null && item != null)
                {
                    ip = item.GetWorldTop();
                    Point3D p = new Point3D(ip);
                    Region region = Region.Find(p, item.Map);
                    if (region is HouseRegion)
                        return true;
                }
            }

            return false;
        }

        // adam: Refresh items so they do not decay
        public void Refresh()
        {
            try
            {
                for (int i = 0; i < m_Objects.Count; ++i)
                {
                    object o = m_Objects[i];
                    if (o is Item)
                    {
                        Item item = (Item)o;
                        if (item.Deleted == false && item.Parent == null && item.Decays == true)
                            item.SetLastMoved();
                    }
                }
            }
            catch (Exception exc)
            {
                LogHelper.LogException(exc);
                System.Console.WriteLine("Exception caught in Spawner.Refresh: " + exc.Message);
                System.Console.WriteLine(exc.StackTrace);
            }
        }

        public void Defrag()
        {
            bool removed = false;

            for (int i = 0; i < m_Objects.Count; ++i)
            {
                object o = m_Objects[i];

                if (o is Item)
                {
                    Item item = (Item)o;

                    // adam: if a player picks up an item (rare) and gets it home before
                    //	defrag() runs, we want to remove it from our list of controled objects
                    //	so that a new item will spawn
                    if (item.Deleted || item.Parent != null || InHouse(o) == true)
                    {
                        m_Objects.RemoveAt(i);
                        --i;
                        removed = true;
                    }
                }
                else if (o is Mobile)
                {
                    Mobile m = (Mobile)o;

                    if (m.Deleted)
                    {
                        m_Objects.RemoveAt(i);
                        --i;
                        removed = true;
                    }
                    else if (m is BaseCreature)
                    {
                        if (((BaseCreature)m).Controlled || ((BaseCreature)m).IsStabled)
                        {
                            m_Objects.RemoveAt(i);
                            --i;
                            removed = true;
                        }
                    }
                }
                else
                {
                    m_Objects.RemoveAt(i);
                    --i;
                    removed = true;
                }
            }

            if (removed)
                InvalidateProperties();
        }

        // make virtual so we can get the tick in our derived class EventTimer
        public virtual void OnTick()
        {
            DoTimer();

            if (m_Group)
            {
                Defrag();

                if (m_Objects.Count == 0)
                {
                    Respawn();
                }
                else
                {
                    return;
                }
            }
            else
            {
                Spawn();
            }
        }

        public static void CopyProperties(Mobile dest, Mobile src)
        {
            PropertyInfo[] props = src.GetType().GetProperties();

            for (int i = 0; i < props.Length; i++)
            {
                try
                {
                    if (props[i].CanRead && props[i].CanWrite)
                    {
                        props[i].SetValue(dest, props[i].GetValue(src, null), null);
                    }
                }
                catch
                {
                    Console.WriteLine("Spawner: Unable to copy property {0}", props[i].Name);
                }
            }
        }

        public static void CopyProperties(Item dest, Item src)
        {
            PropertyInfo[] props = src.GetType().GetProperties();

            for (int i = 0; i < props.Length; i++)
            {
                try
                {
                    if (props[i].CanRead && props[i].CanWrite)
                    {
                        props[i].SetValue(dest, props[i].GetValue(src, null), null);
                    }
                }
                catch
                {
                    Console.WriteLine("Spawner: Unable to copy property {0}", props[i].Name);
                }
            }
        }

        //wipe layers of src mobile, copy identical layers 
        public static void CopyLayers(Mobile dest, Mobile src)
        {
            try
            {
                dest.WipeLayers();
                Item[] items = new Item[21];
                items[0] = src.FindItemOnLayer(Layer.Shoes);
                items[1] = src.FindItemOnLayer(Layer.Pants);
                items[2] = src.FindItemOnLayer(Layer.Shirt);
                items[3] = src.FindItemOnLayer(Layer.Helm);
                items[4] = src.FindItemOnLayer(Layer.Gloves);
                items[5] = src.FindItemOnLayer(Layer.Neck);
                items[6] = src.FindItemOnLayer(Layer.Waist);
                items[7] = src.FindItemOnLayer(Layer.InnerTorso);
                items[8] = src.FindItemOnLayer(Layer.MiddleTorso);
                items[9] = src.FindItemOnLayer(Layer.Arms);
                items[10] = src.FindItemOnLayer(Layer.Cloak);
                items[11] = src.FindItemOnLayer(Layer.OuterTorso);
                items[12] = src.FindItemOnLayer(Layer.OuterLegs);
                items[13] = src.FindItemOnLayer(Layer.InnerLegs);
                items[14] = src.FindItemOnLayer(Layer.Bracelet);
                items[15] = src.FindItemOnLayer(Layer.Ring);
                items[16] = src.FindItemOnLayer(Layer.Earrings);
                items[17] = src.FindItemOnLayer(Layer.OneHanded);
                items[18] = src.FindItemOnLayer(Layer.TwoHanded);
                items[19] = src.FindItemOnLayer(Layer.Hair);
                items[20] = src.FindItemOnLayer(Layer.FacialHair);
                for (int i = 0; i < items.Length; i++)
                {
                    if (items[i] != null)
                    {
                        Type temp = items[i].GetType();
                        object o = Activator.CreateInstance(temp);
                        if (o != null && o is Item)
                        {
                            Item item = (Item)o;
                            CopyProperties(item, items[i]);
                            dest.AddItem(item);
                        }

                    }
                }
            }
            catch (Exception exc)
            {
                LogHelper.LogException(exc);
                System.Console.WriteLine("Send to Zen please: ");
                System.Console.WriteLine("Exception caught in Spawner.CopyLayers: " + exc.Message);
                System.Console.WriteLine(exc.StackTrace);
            }

        }

        public static void CreateTemplate(Spawner Spawner, Type type)
        {
            try
            {
                // cleanup old templates
                if (Spawner.TemplateMobile != null)
                    Spawner.TemplateMobile.Delete();
                Spawner.TemplateMobile = null;

                if (Spawner.TemplateItem != null)
                    Spawner.TemplateItem.Delete();
                Spawner.TemplateItem = null;

                // create a new thingie
                object o = Activator.CreateInstance(type);

                if (o != null && o is BaseCreature)
                {
                    Spawner.TemplateMobile = (BaseCreature)o;
                    Spawner.TemplateMobile.SpawnerTempMob = true;
                    ((BaseCreature)Spawner.TemplateMobile).Spawner = Spawner;
                }

                if (o != null && o is Item)
                {
                    Spawner.TemplateItem = (Item)o;
                    Spawner.TemplateItem.SpawnerTempItem = true; //set are template flag

                }
            }
            catch
            {
                Console.WriteLine("Spawner({0}): Error createing a template based on type", Spawner.Location);
            }
        }

        public void Respawn()
        {
            RemoveObjects();

            for (int i = 0; i < m_Count; i++)
                Spawn();
        }

        public virtual void Spawn()
        {
            if (m_ObjectNames.Count > 0)
                Spawn(Utility.Random(m_ObjectNames.Count));
        }

        public void Spawn(string objectName)
        {
            for (int i = 0; i < m_ObjectNames.Count; i++)
            {
                if ((string)m_ObjectNames[i] == objectName)
                {
                    Spawn(i);
                    break;
                }
            }
        }

        protected virtual void OnAfterMobileSpawn(Mobile m)
        {

        }

        // create the template mob/item for the first item only
        public void CheckTemplate()
        {
            if (TemplateEnabled == false)   // not using templates
                return;

            if (m_Objects.Count == 0)           // there are no creatures defines
                return;

            Type type =                             // get the type
                SpawnerType.GetType((string)m_ObjectNames[0]);

            if (type == null)                       // funky
                return;

            if (TemplateMobile != null && TemplateMobile.GetType() == type)
                return;                             // already set, don't loose the custom mob!

            if (TemplateItem != null && TemplateItem.GetType() == type)
                return;                             // already set, don't loose the custom item!

            CreateTemplate(this, type);             // okay, create a template for this spawner
        }

        public void Spawn(int index)
        {
            Map map = Map;

            if (map == null || map == Map.Internal || m_ObjectNames.Count == 0 || index >= m_ObjectNames.Count)
                return;

            Defrag();

            if (m_Objects.Count >= m_Count)
                return;

            // create the mobile ir item
            object o = CreateRaw((string)m_ObjectNames[index]);

            if (o != null)
            {
                try
                {
                    if (o is Mobile)
                    {
                        Mobile m = (Mobile)o;
                        m_Objects.Add(m);
                        InvalidateProperties();

                        Point3D loc = (m is BaseVendor ? this.Location : GetSpawnPosition(o));
                        OnAfterMobileSpawn(m);   //plasma: new "event" allows you to make changes to the mob after spawn
                        m.MoveToWorld(loc, map);

                    }
                    else if (o is Item)
                    {
                        Item item = (Item)o;
                        m_Objects.Add(item);
                        InvalidateProperties();
                        item.MoveToWorld(GetSpawnPosition(o), map);

                        // Adam: Warn if we're spawning stuff in a house.
                        //	This is a problem becuse the item will be orphaned by the spawer
                        //	which can lead to excessive item generation.
                        if (InHouse(item) == true)
                        {
                            Console.WriteLine("Warning: House spawn: Item({0}, {1}, {2}), Spawner({3}, {4}, {5})", item.Location.X, item.Location.Y, item.Location.Z, this.Location.X, this.Location.Y, this.Location.Z);
                        }
                    }
                }
                catch
                {
                    Console.WriteLine("Warning: Spawner({0}, {1}, {2}) generating object not template compatible", this.Location.X, this.Location.Y, this.Location.Z);
                }
            }
        }

        public object CreateRaw(string name)
        {
            Map map = Map;

            if (map == null || map == Map.Internal)
                return null;

            // make sure the thing we are asked to create existes in our list 
            //  of stuff to create.
            bool bFound = false;
            for (int i = 0; i < m_ObjectNames.Count; i++)
            {
                if (((string)m_ObjectNames[i]).ToLower() == name.ToLower())
                {
                    bFound = true;
                    break;
                }
            }

            if (bFound == false)
                return null;

            Type type = SpawnerType.GetType(name);
            object o = null;

            if (type != null)
            {
                try
                {
                    // if we are using templates. make sure it's created
                    CheckTemplate();

                    o = Activator.CreateInstance(type);

                    if (o != null)
                    {
                        if (o is Mobile)
                        {
                            Mobile m = (Mobile)o;
                            if (m is BaseCreature)
                            {
                                BaseCreature c = (BaseCreature)m;

                                if (m_TemplateEnabled) //copy are template props to the spawning mobile
                                {
                                    TimeSpan OldLifespan = c.Lifespan;
                                    CopyProperties(c, m_TemplateMobile);
                                    //c.InitOutfit(); //call this to prevent cross dressing

                                    if (!DynamicCopy)
                                        CopyLayers(c, m_TemplateMobile);

                                    if (DynamicCopy)
                                    {
                                        //get use a new name/sex/clothing/body layout
                                        c.InitBody();
                                        c.InitOutfit();
                                    }
                                    c.Lifespan = OldLifespan;
                                    c.SpawnerTempMob = false; // Flag this as a template
                                }

                                c.RangeHome = m_HomeRange;

                                c.CurrentWayPoint = m_WayPoint;

                                c.NavDestination = m_NavDest;

                                if (m_Team > 0)
                                    c.Team = m_Team;

                                c.Home = this.Location;

                                //Pix: give the spawned creature a ref to this spawner
                                c.Spawner = this;

                                //if we have a navdestination as soon as we spawn start on it
                                if (c.NavDestination != NavDestinations.None)
                                    c.AIObject.Think();

                                /////////////////////////////
                                // customize the mob spawned
                                if (c is BaseVendor)
                                {
                                    if (m_MobVendorInvul != BOOL.bDefault)
                                    {
                                        ((BaseVendor)c).IsInvulnerable = m_MobVendorInvul == BOOL.bTrue ? true : false;
                                        c.NameHue = -1; //reset hue back to useing notority
                                    }
                                }

                                // it it's not a template mob, it may be a paragon!
                                if (m_TemplateEnabled == false)
                                    if (Utility.RandomChance(10) && HighPowerTameNearby())
                                        c.MakeParagon();
                            }
                        }
                        else if (o is Item)
                        {
                            Item item = (Item)o;

                            if (m_TemplateEnabled)
                            {
                                DateTime OldLastMoved = item.LastMoved;     // used in decay
                                CopyProperties(item, m_TemplateItem);       // copy all props
                                item.LastMoved = OldLastMoved;              // refresh decay
                                item.SpawnerTempItem = false;               // Flag this as a template
                            }

                            // give the spawned item a ref to this spawner
                            item.SpawnerMap = this.Map;
                            item.SpawnerLocation = this.Location;
                        }
                    }
                }
                catch
                {
                    Console.WriteLine("Warning: Spawner({0}, {1}, {2}) generating object not template compatible", this.Location.X, this.Location.Y, this.Location.Z);
                }
            }

            return o;
        }

        // only spawn paragons if we are getting farmed by a highpower tamer/tame
        public bool HighPowerTameNearby()
        {
            // the the tamer is closest enough to see the creature spawn, we can see him! (well, his pet)
            IPooledEnumerable eable = Map.GetMobilesInRange(this.Location, Map.MaxLOSDistance);
            foreach (Mobile m in eable)
            {
                // ignore staff
                if (m.AccessLevel > AccessLevel.Player)
                    continue;

                // if a creature 
                if (m is BaseCreature)
                {   // if controlled (summoned or tame)
                    if (((m as BaseCreature).Controlled && (m as BaseCreature).ControlMaster != null) || ((m as BaseCreature).Summoned && (m as BaseCreature).SummonMaster != null))
                    {   // only trap tame dragons and daemons for now
                        if (m is Dragon || m is Daemon)
                        {
                            eable.Free();
                            return true;
                        }
                    }
                }

            }
            eable.Free();

            return false;
        }

        /*public Point3D GetSpawnPosition(object o)
		{
			CanFitFlags flags = CanFitFlags.requireSurface;
			if (o is Mobile)
			{
				Mobile m = o as Mobile;
				if (m != null && m.CanSwim == true) flags |= CanFitFlags.canSwim;
				if (m != null && m.CantWalk == true) flags |= CanFitFlags.cantWalk;
			}

			if (Map == null)
				return Location;

			// Try 10 times to find a Spawnable location.
			for (int i = 0; i < 10; i++)
			{
				int x = Location.X + (Utility.Random((m_HomeRange * 2) + 1) - m_HomeRange);
				int y = Location.Y + (Utility.Random((m_HomeRange * 2) + 1) - m_HomeRange);
				int z = Map.GetAverageZ(x, y);

				if (Map.CanSpawnMobile(new Point2D(x, y), this.Z, flags))
					return new Point3D(x, y, this.Z);
				if (Map.CanSpawnMobile(new Point2D(x, y), z, flags))
					return new Point3D(x, y, z);
			}

			return this.Location;
		}*/

        public Point3D GetSpawnPosition(object o)
        {
            return GetSpawnPosition(Map, Location, m_HomeRange, false, o);
        }

        public static Point3D GetSpawnPosition(Map map, Point3D location, int homeRange, bool forceZ, object o)
        {
            CanFitFlags flags = CanFitFlags.requireSurface;
            if (o is Mobile)
            {
                Mobile m = o as Mobile;
                if (m != null && m.CanSwim == true) flags |= CanFitFlags.canSwim;
                if (m != null && m.CantWalk == true) flags |= CanFitFlags.cantWalk;
            }

            if (map == null)
                return location;

            // Try 10 times to find a Spawnable location.
            for (int i = 0; i < 10; i++)
            {
                int x = location.X + (Utility.Random((homeRange * 2) + 1) - homeRange);
                int y = location.Y + (Utility.Random((homeRange * 2) + 1) - homeRange);
                int z = map.GetAverageZ(x, y);

                if (map.CanSpawnMobile(new Point2D(x, y), location.Z, flags))
                    return new Point3D(x, y, location.Z);
                if (forceZ == false)
                    if (map.CanSpawnMobile(new Point2D(x, y), z, flags))
                        return new Point3D(x, y, z);
            }

            return location;
        }

        public enum SpawnFlags
        {
            None,
            SpawnFar
        }

        public static Point3D GetSpawnPosition(Map map, Point3D location, int homeRange, bool forceZ, bool avoidPlayers, SpawnFlags sflags, Mobile m)
        {
            CanFitFlags flags = CanFitFlags.requireSurface;
            if (m != null && m.CanSwim == true) flags |= CanFitFlags.canSwim;
            if (m != null && m.CantWalk == true) flags |= CanFitFlags.cantWalk;

            if (map == null)
                return location;

            // Try 10 times to find a spawnable location not near a player.
            if (avoidPlayers)
                for (int i = 0; i < 10; i++)
                {
                    int x;
                    int y;
                    if ((sflags & SpawnFlags.SpawnFar) != 0)
                    {
                        x = (int)((double)location.X + Spawner.RandomFar() * (double)homeRange);
                        y = (int)((double)location.Y + Spawner.RandomFar() * (double)homeRange);
                    }
                    else
                    {
                        x = location.X + (Utility.Random((homeRange * 2) + 1) - homeRange);
                        y = location.Y + (Utility.Random((homeRange * 2) + 1) - homeRange);
                    }
                    int z = map.GetAverageZ(x, y);

                    if (map.CanSpawnMobile(new Point2D(x, y), location.Z, flags) && !NearPlayer(map, new Point3D(x, y, location.Z)))
                        return new Point3D(x, y, location.Z);
                    if (forceZ == false)
                        if (map.CanSpawnMobile(new Point2D(x, y), z, flags) && !NearPlayer(map, new Point3D(x, y, z)))
                            return new Point3D(x, y, z);
                }

            // Try 10 more times to find a any spawnable location.
            for (int i = 0; i < 10; i++)
            {
                int x;
                int y;
                if ((sflags & SpawnFlags.SpawnFar) != 0)
                {
                    x = (int)((double)location.X + Spawner.RandomFar() * (double)homeRange);
                    y = (int)((double)location.Y + Spawner.RandomFar() * (double)homeRange);
                }
                else
                {
                    x = location.X + (Utility.Random((homeRange * 2) + 1) - homeRange);
                    y = location.Y + (Utility.Random((homeRange * 2) + 1) - homeRange);
                }
                int z = map.GetAverageZ(x, y);

                if (map.CanSpawnMobile(new Point2D(x, y), location.Z, flags))
                    return new Point3D(x, y, location.Z);
                if (forceZ == false)
                    if (map.CanSpawnMobile(new Point2D(x, y), z, flags))
                        return new Point3D(x, y, z);

            }

            return location;
        }

        public static bool NearPlayer(Map map, Point3D px)
        {
            IPooledEnumerable eable = map.GetMobilesInRange(px, 15);
            foreach (Mobile m in eable)
            {
                if (m is PlayerMobile && m.AccessLevel <= AccessLevel.Player)
                {
                    eable.Free();
                    return true;
                }
            }
            eable.Free();

            return false;
        }

        public void DoTimer()
        {
            if (!m_Running)
                return;

            int minSeconds = (int)m_MinDelay.TotalSeconds;
            int maxSeconds = (int)m_MaxDelay.TotalSeconds;

            TimeSpan delay = TimeSpan.FromSeconds(Utility.RandomMinMax(minSeconds, maxSeconds));
            DoTimer(delay);
        }

        public void DoTimer(TimeSpan delay)
        {
            if (!m_Running)
                return;

            m_End = DateTime.UtcNow + delay;

            if (m_Timer != null)
            {
                m_Timer.Stop();         // stop the timer
                m_Timer.Flush();        // remove any queued ticks
            }

            m_Timer = new InternalTimer(this, delay);
            m_Timer.Start();
        }

        private class InternalTimer : Timer
        {
            private Spawner m_Spawner;

            public InternalTimer(Spawner spawner, TimeSpan delay)
                : base(delay)
            {
                if (spawner.IsFull)
                    Priority = TimerPriority.FiveSeconds;
                else
                    Priority = TimerPriority.OneSecond;

                m_Spawner = spawner as Spawner;
            }

            protected override void OnTick()
            {
                if (m_Spawner != null && !m_Spawner.Deleted)
                {
                    // We will disable ourself if we are not part of the active configuration.
                    if ((m_Spawner.OurWorldSize & CoreAI.CurrentWorldSize) == 0)
                    {   // shut it down
                        m_Spawner.Running = false;
                        m_Spawner.RemoveObjects();
                        return;
                    }

                    m_Spawner.OnTick();
                }
            }
        }

        public int CountObjects(string objectName)
        {
            Defrag();

            int count = 0;

            for (int i = 0; i < m_Objects.Count; ++i)
                if (Insensitive.Equals(objectName, m_Objects[i].GetType().Name))
                    ++count;

            return count;
        }

        public void RemoveObjects(string objectName)
        {
            Defrag();

            objectName = objectName.ToLower();

            for (int i = 0; i < m_Objects.Count; ++i)
            {
                object o = m_Objects[i];

                if (Insensitive.Equals(objectName, o.GetType().Name))
                {
                    if (o is Item)
                        ((Item)o).Delete();
                    else if (o is Mobile)
                        ((Mobile)o).Delete();
                }
            }

            InvalidateProperties();
        }

        public void RemoveObjects()
        {
            Defrag();

            for (int i = 0; i < m_Objects.Count; ++i)
            {
                object o = m_Objects[i];

                if (o is Item)
                    ((Item)o).Delete();
                else if (o is Mobile)
                    ((Mobile)o).Delete();
            }

            InvalidateProperties();
        }

        public static double RandomFar()
        {
            if (Utility.RandomBool())
                return -Math.Sqrt(Utility.RandomDouble());
            else
                return Math.Sqrt(Utility.RandomDouble());

            // if you want a steeper congregation toward the outside, replace Math.Sqrt(...) with Math.Pow(Utility.RandomDouble(), .33);
            // Pow(x, .33) is cube root, .25 is 4th root etc, etc
            // basically the higher the root, the sharper the dropoff toward center will be
        }

        public void BringToHome()
        {
            Defrag();

            for (int i = 0; i < m_Objects.Count; ++i)
            {
                object o = m_Objects[i];

                if (o is Mobile)
                {
                    Mobile m = (Mobile)o;

                    m.MoveToWorld(Location, Map);
                }
                else if (o is Item)
                {
                    Item item = (Item)o;

                    item.MoveToWorld(Location, Map);
                }
            }
        }

        // erl: for change logging!

        public void LogChange(string changemade)
        {
            if (changemade == "")
                return;

            StreamWriter LogFile = new StreamWriter("logs/spawnerchange.log", true);

            string strAcc = "";

            if (m_LastProps is PlayerMobile)
                strAcc = m_LastProps.Account.ToString();
            else
                strAcc = "SYSTEM";

            LogFile.WriteLine("{0}, {1}, {2}, {3}, {4}, {5} {6}", DateTime.UtcNow, strAcc, this.Location.X, this.Location.Y, this.Location.Z,
                (this.ObjectNames != null && this.ObjectNames.Count > 0) ? this.ObjectNames[0] : "-null-", changemade);

            LogFile.Close();

        }

        public override void OnDelete()
        {
            base.OnDelete();

            // Remove Templates
            if (this.LootPack != null && this.LootPack.Deleted == false)
                this.LootPack.Delete();

            if (TemplateMobile != null && TemplateMobile.Deleted == false)
                TemplateMobile.Delete();

            if (TemplateItem != null && TemplateItem.Deleted == false)
                TemplateItem.Delete();

            // Remove Creatures
            RemoveObjects();
            if (m_Timer != null)
                m_Timer.Stop();

            // erl: Log the fact it's been deleted
            LogChange("Spawner deleted");

        }

        public override void Serialize(GenericWriter writer)
        {
            base.Serialize(writer);

            writer.Write((int)12); // version

            //v12
            writer.Write((int)m_OurWorldSize);

            // v11
            writer.Write(m_LootPack);

            // v10
            writer.Write(m_DynamicCopy);
            writer.Write(m_TemplateMobile);
            writer.Write(m_TemplateItem);

            writer.Write((bool)m_TemplateEnabled);

            writer.Write((int)m_MobVendorInvul); // 8

            writer.Write(false);
            writer.Write(0);
            writer.Write(0);
            writer.Write(0);
            writer.Write(0);
            writer.Write(0);
            writer.Write(0);
            writer.Write(0);
            writer.Write("0");
            writer.Write(0);
            writer.Write((int)m_NavDest);
            writer.Write((int)m_MobDirection);
            writer.Write(false);                // obsolete: m_FreezeDecay
            writer.Write(m_WayPoint);
            writer.Write(m_Group);
            writer.Write(m_MinDelay);
            writer.Write(m_MaxDelay);
            writer.Write(m_Count);
            writer.Write(m_Team);
            writer.Write(m_HomeRange);
            writer.Write(m_Running);

            if (m_Running)
                writer.WriteDeltaTime(m_End);

            writer.Write(m_ObjectNames.Count);

            for (int i = 0; i < m_ObjectNames.Count; ++i)
                writer.Write((string)m_ObjectNames[i]);

            writer.Write(m_Objects.Count);

            for (int i = 0; i < m_Objects.Count; ++i)
            {
                object o = m_Objects[i];

                if (o is Item)
                    writer.Write((Item)o);
                else if (o is Mobile)
                    writer.Write((Mobile)o);
                else
                    writer.Write(Serial.MinusOne);
            }
        }

        private static WarnTimer m_WarnTimer;

        public override void Deserialize(GenericReader reader)
        {
            base.Deserialize(reader);

            int version = reader.ReadInt();

            switch (version)
            {
                case 12:
                    {
                        m_OurWorldSize = (CoreAI.WorldSize)reader.ReadInt();
                        goto case 11;
                    }
                case 11:
                    {
                        m_LootPack = reader.ReadItem();
                        goto case 10;
                    }
                case 10:
                    {
                        m_DynamicCopy = reader.ReadBool();
                        goto case 9;
                    }
                case 9:
                    {
                        m_TemplateMobile = reader.ReadMobile();
                        m_TemplateItem = reader.ReadItem();
                        m_TemplateEnabled = reader.ReadBool();

                        goto case 8;
                    }
                case 8:
                    {

                        m_MobVendorInvul = (BOOL)reader.ReadInt();
                        goto case 7;
                    }
                case 7:
                    {
                        int dummy = 0;
                        bool b = reader.ReadBool();
                        dummy = reader.ReadInt();
                        dummy = reader.ReadInt();
                        dummy = reader.ReadInt();
                        dummy = reader.ReadInt();
                        dummy = reader.ReadInt();
                        dummy = reader.ReadInt();
                        dummy = reader.ReadInt();
                        goto case 6;
                    }
                case 6:
                    {
                        int dummy = 0;
                        string s = reader.ReadString();
                        dummy = reader.ReadInt();
                        goto case 5;
                    }
                case 5:
                    {
                        m_NavDest = (NavDestinations)reader.ReadInt();
                        goto case 4;
                    }
                case 4:
                    {
                        m_MobDirection = (Direction)reader.ReadInt();
                        goto case 3;
                    }
                case 3:
                    {   // obsolete: m_FreezeDecay
                        bool dmy = reader.ReadBool();
                        goto case 2;
                    }

                case 2:
                    {
                        m_WayPoint = reader.ReadItem() as WayPoint;

                        goto case 1;
                    }

                case 1:
                    {
                        m_Group = reader.ReadBool();

                        goto case 0;
                    }

                case 0:
                    {
                        m_MinDelay = reader.ReadTimeSpan();
                        m_MaxDelay = reader.ReadTimeSpan();
                        m_Count = reader.ReadInt();
                        m_Team = reader.ReadInt();
                        m_HomeRange = reader.ReadInt();
                        m_Running = reader.ReadBool();

                        TimeSpan ts = TimeSpan.Zero;

                        if (m_Running)
                            ts = reader.ReadDeltaTime() - DateTime.UtcNow;

                        int size = reader.ReadInt();

                        m_ObjectNames = new ArrayList(size);

                        for (int i = 0; i < size; ++i)
                        {
                            string typeName = reader.ReadString();

                            m_ObjectNames.Add(typeName);

                            if (SpawnerType.GetType(typeName) == null)
                            {
                                if (m_WarnTimer == null)
                                    m_WarnTimer = new WarnTimer();

                                m_WarnTimer.Add(Location, Map, typeName);
                            }
                        }

                        int count = reader.ReadInt();

                        m_Objects = new ArrayList(count);

                        for (int i = 0; i < count; ++i)
                        {
                            IEntity e = World.FindEntity(reader.ReadInt());

                            if (e != null)
                                m_Objects.Add(e);
                        }

                        if (m_Running)
                            DoTimer(ts);

                        break;
                    }
            }
        }

        private class WarnTimer : Timer
        {
            private ArrayList m_List;

            private class WarnEntry
            {
                public Point3D m_Point;
                public Map m_Map;
                public string m_Name;

                public WarnEntry(Point3D p, Map map, string name)
                {
                    m_Point = p;
                    m_Map = map;
                    m_Name = name;
                }
            }

            public WarnTimer()
                : base(TimeSpan.FromSeconds(1.0))
            {
                m_List = new ArrayList();
                Start();
            }

            public void Add(Point3D p, Map map, string name)
            {
                m_List.Add(new WarnEntry(p, map, name));
            }

            protected override void OnTick()
            {
                try
                {
                    Console.WriteLine("Warning: {0} bad spawns detected, logged: 'badspawn.log'", m_List.Count);

                    using (StreamWriter op = new StreamWriter("badspawn.log", true))
                    {
                        op.WriteLine("# Bad spawns : {0}", DateTime.UtcNow);
                        op.WriteLine("# Format: X Y Z F Name");
                        op.WriteLine();

                        foreach (WarnEntry e in m_List)
                            op.WriteLine("{0}\t{1}\t{2}\t{3}\t{4}", e.m_Point.X, e.m_Point.Y, e.m_Point.Z, e.m_Map, e.m_Name);

                        op.WriteLine();
                        op.WriteLine();
                    }
                }
                catch (Exception ex) { EventSink.InvokeLogException(new LogExceptionEventArgs(ex)); }
            }
        }
    }

    class EventSpawner : Spawner
    {
        private DateTime m_EventEnd = DateTime.UtcNow + TimeSpan.FromHours(24.0);
        private DateTime m_EventStart = DateTime.UtcNow;
        private InternalTimer m_Timer;

        // you can specify either an expiration date or countdown timer.
        [CommandProperty(AccessLevel.Seer)]
        public TimeSpan CountDown
        {
            get { return m_EventEnd - DateTime.UtcNow; }
            set
            {
                if (m_Timer != null)
                {
                    m_Timer.Stop();
                    m_Timer.Flush();        // remove any queued ticks
                }
                m_EventEnd = DateTime.UtcNow + value;
                m_Timer = new InternalTimer(this, CountDown);
                m_Timer.Start();
            }
        }

        // wait until event start to spawn anything
        [CommandProperty(AccessLevel.Seer)]
        public DateTime EventStart
        {
            get { return m_EventStart; }
            set { m_EventStart = value; }
        }

        // you can specify either an expiration date or countdown timer.
        [CommandProperty(AccessLevel.Seer)]
        public DateTime EventEnd
        {
            get { return m_EventEnd; }
            set
            {
                if (m_Timer != null)
                {
                    m_Timer.Stop();
                    m_Timer.Flush();        // remove any queued ticks
                }
                m_EventEnd = value;
                m_Timer = new InternalTimer(this, CountDown);
                m_Timer.Start();
            }
        }

        [Constructable]
        public EventSpawner()
            : base()
        {
            m_Timer = new InternalTimer(this, CountDown);
            m_Timer.Start();
        }

        public EventSpawner(Serial serial)
            : base(serial)
        {
        }

        #region destroy timer
        private class InternalTimer : Timer
        {
            private EventSpawner m_Spawner;

            public InternalTimer(EventSpawner spawner, TimeSpan delay)
                : base(delay)
            {
                Priority = TimerPriority.OneSecond;
                m_Spawner = spawner;
            }

            protected override void OnTick()
            {
                m_Spawner.Delete();
            }
        }
        #endregion

        public override void OnTick()
        {
            // spawn stuffs during event only
            if (DateTime.UtcNow >= EventStart && DateTime.UtcNow < EventEnd)
                base.OnTick();      // spawn and reset timer
            else
                base.DoTimer();     // reset timer only
        }

        public override void OnDelete()
        {
            base.OnDelete();

            if (m_Timer != null)
            {
                m_Timer.Stop();
                m_Timer.Flush();        // remove any queued ticks
            }
        }

        public override void OnSingleClick(Mobile from)
        {
            LabelTo(from, String.Format("Event Spawner"));

            /*if (OurWorldSize.ToString().Contains(","))
				LabelTo(from, String.Format("for {0} worlds", OurWorldSize.ToString()));
			else
				LabelTo(from, String.Format("for a {0} world", OurWorldSize.ToString()));*/

            LabelTo(from, String.Format("Self destruct countdown: {0}", this.CountDown));

            if (base.Running)
                LabelTo(from, "[Running]");
            else
                LabelTo(from, "[Off]");
        }

        public override void Serialize(GenericWriter writer)
        {
            base.Serialize(writer);
            writer.Write((int)2);   // version

            // version 2
            writer.WriteDeltaTime(m_EventStart);

            // version 1
            writer.WriteDeltaTime(m_EventEnd);
        }

        public override void Deserialize(GenericReader reader)
        {
            base.Deserialize(reader);

            int version = reader.ReadInt();

            switch (version)
            {
                case 2:
                    {
                        m_EventStart = reader.ReadDeltaTime();
                        goto case 1;
                    }
                    break;

                case 1:
                    {
                        m_EventEnd = reader.ReadDeltaTime();
                        m_Timer = new InternalTimer(this, CountDown);
                        m_Timer.Start();
                        goto case 0;
                    }
                    break;

                case 0:
                    {
                    }
                    break;
            }
        }
    }
}
